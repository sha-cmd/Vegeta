#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Oct 12 16:15:02 2020
Ce programme analyse et crée un rapport financier
@author: romain Boyrie
"""
#from data import listes
import string
import weakref
#import memory_profiler
import time
import matplotlib.pyplot as plt
import mplfinance as mpf
import seaborn as sns
from scipy import stats
import pandas as pd
import numpy as np
from scipy.stats import norm
from decimal import Decimal
from datetime import datetime

import os
import gc
DATE_DU_JOUR = datetime.now().date().strftime('%Y-%m-%d')
DATE_DE_DERNIERE_SEANCE = np.datetime_as_string(np.busday_offset(
    DATE_DU_JOUR,
    offsets=-1,
    roll='forward'))


START = r"""% LaTeX Cookbook, Packt Publishing, 2015
% Stefan Kottwitz
\documentclass[11pt,a4paper]{report}% compile with LuaLaTeX
%\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
%\usepackage{lua-visual-debug}
\usepackage{sansmath}
\usepackage{mathtools}
\usepackage{graphicx} % utiliser des images seulement ou des figures seulement
\usepackage{lmodern}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{listings} % utiliser les listes
\usepackage{graphicx} % utiliser des images seulement ou des figures seulement
\usepackage{xcolor} % for setting colors
\usepackage{color}
\usepackage{verbatim} % Package pour de grand morceaux de code brut
\usepackage{moreverb} % Permet de g\'erer les tabulations // \begin{verbatim}[4]
\usepackage{color}
\usepackage{float} % To place floating image
\usepackage{booktabs}
\usepackage{datatool}
\usepackage{csvsimple}
\usepackage{csquotes}
%\usepackage{dsfont}
%\usepackage{slashbox,multirow}
\usepackage{bookman}
\usepackage{textcomp}
\usepackage{eurosym}
\usepackage{numprint}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}
\usepackage{appendix}
\usepackage[pdftex,colorlinks=true,linkcolor=black,citecolor=blue,urlcolor=blue]{hyperref}

\graphicspath{{../Images/}} %Setting the graphicspath

% set the default code style
\lstset{
    language=Python,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{green}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    backgroundcolor=\color{mygray}, % couleur de fond
    tabsize=4,
}

\title{Ville de Paris
\\Rapport Espaces Verts}
\author{ROMAIN BOYRIE}
\date{DATE} 

\begin{document}

\pagestyle{headings}
%\frontmatter
\maketitle
%\mainmatter
\pagenumbering{arabic}
\tableofcontents
"""
CHAPITRE = """\chapter{PARAMETRE}
"""
END = "\end{document}"
CORPSSECTION = r"""

\section{PARAMETRE}


\paragraph{Voici un présentation graphique du GENRENAME} : \par{}"""

#CORPSSITE = r"""(Ctrl + Clic)$<-$\href{SITE}{site web}"""
#CORPSWIKI = r""", \href{WIKI}{wikipédia}"""
#CORPSBOURSORAMA = r""", \href{BOURSORAMA}{boursorama}"""
#CORPSLAPOSTE = r""", \href{LAPOSTE}{informations financières}"""
#CORPSLEREVENU = r""", \href{LEREVENU}{informations journalistiques}"""
CORPS = r"""
\begin{figure}%[!htb]
   %\begin{minipage}{0.5\textwidth}
     \centering
     \includegraphics[width=0.7\linewidth]{Genre_Stad_Domani_GENRENAME.png}
     \caption{Maturité selon Domanialité}\label{Fig:GSD_GENRENAME}
   %\end{minipage}\hfill

   % \begin{minipage}{0.5\textwidth}
     \centering
     \includegraphics[width=0.7\linewidth]{Genre_Hauteur_Stad_GENRENAME.png}
     \caption{Hauteur suivant Maturité}\label{Fig:GHS_GENRENAME}
  % \end{minipage}
\end{figure}
\begin{figure}%[!htb]
   %\begin{minipage}{0.5\textwidth}
     \centering
     \includegraphics[width=0.7\linewidth]{Genre_Hauteur_Domani_GENRENAME.png}
     \caption{Hauteur selon domanité}\label{Fig:GHD_GENRENAME}
   %\end{minipage}\hfill
\end{figure}
\begin{figure}%[!htb]
   %\begin{minipage}{0.5\textwidth}
     \centering
     \includegraphics[width=0.7\linewidth]{Genre_Distro_Espece_GENRENAME.png}
     \caption{Hauteurs par Espece}\label{Fig:GDV_GENRENAME}
   %\end{minipage}\hfill
\end{figure}
\begin{figure}%[!htb]
   %\begin{minipage}{0.5\textwidth}
     \centering
     \includegraphics[width=0.7\linewidth]{Genre_Densite_Circonf_GENRENAME.png}
     \caption{Densité de circonférence}\label{Fig:GDC_GENRENAME}
   %\end{minipage}\hfill
\end{figure}


"""

TABLE = r"""
% Table generated by Excel2LaTeX from sheet 'Feuil1'
\begin{table}[H]
  \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    arbres & espece & variété  & haut/moy & std & remarquable & lieu & pourcent \\
    \hline
    PRIX &    ROR    & RISQUE & LOG & STD & CINQ & TROIS  & UN \% \\
    \hline
    \end{tabular}%
        \label{tab:table_TITRE}%
      \caption{Tableau de valeurs}
\end{table}%


"""

#DESCRIPTION = r"""\paragraph{Ses activités sont : } ACTIVITE

#    """
#from objects.singleton import SingletonType


# class PlotFinance(metaclass=SingletonType):
#     def __init__(self):
#         pass
#
#
#     def calc(self, data, nom, methode):
#         m1 = memory_profiler.memory_usage()
#         t1 = time.perf_counter()
#         sns.set_style("darkgrid", {"axes.facecolor": ".9"})
#         top = plt.subplot2grid((4, 4), (0, 0), rowspan=3, colspan=4)
#         top.plot(data.index, data['Adj Close'], label='Prix à la Clôture')
#         plt.title("Cours de l'action {}".format(nom))
#         plt.legend(loc=2)
#         plt.gcf().set_size_inches(10, 10)
#         plt.savefig('OutputFiles/stockprice_' + methode + '_' + nom + '.png')
#
#         # plt.show()
#         plt.clf()
#         plt.close()
#         # p = mpf.plot(data.iloc[:,0:5], type='line',volume=False, title='Cours de l\'action ' + nom
#         #            ,savefig='OutputFiles/stockprice_' + methode + '_' + nom + '.png')
#         # plt.clf()
#         # plt.close()
#         t2 = time.perf_counter()
#         m2 = memory_profiler.memory_usage()
#         time_diff = t2 - t1
#         mem_diff = m2[0] - m1[0]
#         print(f"It took {time_diff} Secs and {mem_diff} Mb to execute this p method")
#
#         m1 = memory_profiler.memory_usage()
#         t1 = time.perf_counter()
#         q = mpf.plot(data.iloc[-500:, 0:5], type='line', mav=(12, 20, 50), volume=True,
#                      title='Cours de l\'action ' + nom
#                      , savefig='OutputFiles/mva_' + methode + '_' + nom + '.png')
#         plt.clf()
#         plt.close()
#         t2 = time.perf_counter()
#         m2 = memory_profiler.memory_usage()
#         time_diff = t2 - t1
#         mem_diff = m2[0] - m1[0]
#         print(f"It took {time_diff} Secs and {mem_diff} Mb to execute this q method")
#
#         plt.close('all')
#         # del data, nom, methode
#         # data = ''
#         # nom = ''
#         # methode = ''
#         # del data, nom, methode
#         # gc.collect()
#         # return 0


class Report:
    def __init__(self):
        print('Report')
        self.data_builder()
        #self.data = analyse
        #self.secteurs = pd.unique([self.data.df.loc[self.data.df['Nom'] == nom._nom]['Secteur'].values[0] for nom in
                               #self.data._portefeuille._liste_valeurs if
                                #   len(self.data.df.loc[self.data.df['Nom'] == nom._nom]['Secteur'].values) > 0])
        #self.noms = {nom._nom: self.data.df.loc[self.data.df['Nom'] == nom._nom]['Secteur'].values for nom in
        #         self.data._portefeuille._liste_valeurs}

    def data_builder(self):
        self.data = pd.DataFrame()
        self.d = pd.DataFrame()
        self.quant_gen = pd.DataFrame()
        self.genres_list = list()
        self.especes_list = list()
        self.varietes_list = list()
        self.quant_gen_filtre = pd.read_excel('quant_gen_filtre.xlsx')
        self.quant_gen = pd.read_excel('quant_gen.xlsx')
        data = pd.read_csv('data.csv', sep=';')
        data.drop('id', axis=1, inplace=True)
        data.drop('numero', axis=1, inplace=True)
        data['remarquable'].fillna(value=0, inplace=True)
        data['remarquable'] = data['remarquable'].map({0.: False, 1.: True})
        data['remarquable'] = data['remarquable'].convert_dtypes()
        colonnes = ['arrondissement', 'type_emplacement', 'lieu', 'id_emplacement']
        for col in colonnes:
            data[col] = data[col].convert_dtypes(convert_string=True)
        colonnes = ['stade_developpement', 'espece', 'variete', 'genre', 'libelle_francais', \
                    'complement_addresse', 'domanialite']
        for col in colonnes:
            data[col].fillna(value="", inplace=True)
            data[col] = data[col].convert_dtypes(convert_string=True)
        data['stade_developpement'] = data.stade_developpement.map({'': 'P', 'A': 'A', 'JA': 'JA', 'M': 'M', 'J': 'J'})
        data['sta_dev_num'] = data.stade_developpement.map({'J': 1, 'P': 2, 'JA': 3, 'A': 4, 'M': 5})

        # Filtrage des données aberrantes :
        self.data = data.copy()
        #self.data['std_dev_num'] = self.data['stade_developpement'].map({'J': 1, 'P': 2, 'JA': 3, 'A': 4, 'M': 5})
        self.d = data.loc[((data["hauteur_m"] < 21) )
                     & ((data["circonference_cm"] < 255))].copy()
        #self.d['std_dev_num'] = self.d.stade_developpement.map({'J': 1, 'P': 2, 'JA': 3, 'A': 4, 'M': 5})
        self.genres_list = list(self.data['genre'].unique())
        self.especes_list = list(self.data['espece'].unique())
        self.varietes_list = list(self.data['variete'].unique())

    def plot(self):

        self.graph_sta_dev_num()
        self.graph_hauteur_m()
        self.graph_distro()
        self.graph_densite()
        #self.grah_circonference_cm()
        # self.graph_pme()
        # self.graph_fonds()
        # self.graph_indices()
        # self.graph_bitcoins()
        # self.graph_pea_vol()
        # self.graph_pea_quant()
        # self.graph_pea_cours()
        # self.sim_pea()
        # self.sim_pme()
        # self.sim_fonds()
        # self.sim_indices()
        # self.sim_bitcoins()

    def compiler(self):
        # os.chdir("reports_pdf")
        os.system("pdflatex " + DATE_DE_DERNIERE_SEANCE + '.tex')
        os.system("pdflatex " + DATE_DE_DERNIERE_SEANCE + '.tex')

    def create(self):  # (filename, noms, synthese, titre_chapitre, strategie):
        os.chdir("reports_pdf")
        with open(DATE_DE_DERNIERE_SEANCE + '.tex', 'w', encoding='utf8') as fout:
            fout.write(START.replace('DATE', DATE_DE_DERNIERE_SEANCE))

            for secteur in [x for x in string.ascii_uppercase]:
                #noms = [nom for nom in self.genres_list \
                 #       if (self.noms[nom][0] == secteur)]
                # if not secteur == 'Indice':
                if [x for x in self.genres_list if x.startswith(secteur)] ==[]:
                    continue
                fout.write(CHAPITRE.replace('PARAMETRE', secteur))
                # print(secteur, noms)
               # liste_de_parcours =
                for name in [x for x in self.genres_list if x.startswith(secteur)]:
                    fout.write(CORPSSECTION.replace('GENRENAME', name).replace('PARAMETRE', name))
                    #try:
                    #    fout.write(CORPSSITE.replace('SITE',
                    #                                 self.data.df.loc[self.data.df['Nom'] == name]['Adresse'].values[
                    #                                     0]))
                    #except:
                    #    pass
                    #try:
                    #    fout.write(
                    #        CORPSWIKI.replace('WIKI', self.data.df.loc[self.data.df['Nom'] == name]['Wiki'].values[0]))
                    #except:
                    #    pass
                    # try:
                    #     fout.write(CORPSBOURSORAMA.replace('BOURSORAMA', self.data.df.loc[self.data.df['Nom'] == name][
                    #         'Boursorama'].values[0]))
                    # except:
                    #     pass
                    # try:
                    #     fout.write(CORPSLAPOSTE.replace('LAPOSTE',
                    #                                     self.data.df.loc[self.data.df['Nom'] == name]['Laposte'].values[
                    #                                         0]))
                    # except:
                    #     pass
                    # try:
                    #     fout.write(CORPSLEREVENU.replace('LEREVENU', self.data.df.loc[self.data.df['Nom'] == name][
                    #         'Lerevenu'].values[0]))
                    # except:
                    #     pass
                    print(self.quant_gen['arbres'].loc[self.quant_gen['genre'] == name], name)
                    fout.write(CORPS.replace('PARAMETRE', name).replace('TITRE', name).replace('GENRENAME', name))
                    fout.write(
                         TABLE.replace('PRIX', str(self.quant_gen['arbres'].loc[self.quant_gen['genre'] == name].values[0])).replace('TITRE', name)
                                                    .replace('ROR', str(self.quant_gen['espece'].loc[self.quant_gen['genre'] == name].values[0]))
                                                    .replace('LOG', str(round(self.d['hauteur_m'].loc[self.d['genre'] == name].mean(),2)))

                                                    .replace('STD', str(round(self.d['hauteur_m'].loc[self.d['genre'] == name].std(), 2)))

                                                    .replace('CINQ', str(self.quant_gen['remarq'].loc[self.quant_gen['genre'] == name].values[0]))
                                                    .replace('TROIS', str(self.quant_gen['lieu'].loc[self.quant_gen['genre'] == name].values[0]))
                                                    .replace('UN', str(self.quant_gen['pourcent'].loc[self.quant_gen['genre'] == name].values[0]))
                            # .replace('10J',str(round(Decimal(synthese.loc[synthese['Nom'] == name]['10jours'].values[0]),2)))
                            # .replace('6J',str(round(Decimal(synthese.loc[synthese['Nom'] == name]['25jours'].values[0]),2)))
                                                    .replace('RISQUE', str(self.quant_gen['variete'].loc[self.quant_gen['genre'] == name].values[0])))

                    # if strategie.loc[strategie['Nom']==name].empty:
                    #    pass
                    # else:
                    # try:
                    #     fout.write(DESCRIPTION.replace('ACTIVITE',
                    #                                    self.data.df.loc[self.data.df['Nom'] == name]['Activité'].values[
                    #                                        0]))
                    # except:
                    #     pass
                    fout.write(r'\newpage')
            fout.write(END)

    def graph_sta_dev_num(self):
        dom_order_list = list((self.d['domanialite'].unique())).sort()

        for genre in self.genres_list:
            f = plt.figure(figsize=(20, 10))
            ax = sns.violinplot(order=dom_order_list, x="domanialite", y="sta_dev_num", data=self.data.loc[self.data['genre'] == genre], inner=None, scale='width')
            ax = sns.stripplot(order=dom_order_list, x="domanialite", y="sta_dev_num", data=self.data.loc[self.data['genre'] == genre]).set(title=genre.title())
            f.savefig('Images/Genre_Stad_Domani_' + genre + '.png')
            plt.clf()
            plt.close('all')

    def graph_hauteur_m(self):
        dom_order_list = list((self.d['domanialite'].unique())).sort()
        for genre in self.genres_list:
            f = plt.figure(figsize=(20, 10))
            ax = sns.violinplot(x="domanialite", y="hauteur_m", data=self.d.loc[self.d['genre'] == genre], inner=None, scale='width')
            ax = sns.stripplot(order=dom_order_list, x="domanialite", y="hauteur_m", data=self.d.loc[self.d['genre'] == genre]).set(title=genre.title())
            f.savefig('Images/Genre_Hauteur_Domani_' + genre + '.png')
            plt.clf()
            plt.close('all')

        for genre in self.genres_list:
            f = plt.figure(figsize=(20, 10))
            try:
                ax = sns.violinplot(order=[1,2,3,4,5], x="sta_dev_num", y="hauteur_m", data=self.d.loc[self.d['genre'] == genre], inner=None, scale='width')
                ax = sns.stripplot(order=[1,2,3,4,5], x="sta_dev_num", y="hauteur_m", data=self.d.loc[self.d['genre'] == genre]).set(title=genre.title())
            except:
                pass
            f.savefig('Images/Genre_Hauteur_Stad_' + genre + '.png')
            plt.clf()
            plt.close('all')

    def graph_distro(self):
        for genre in self.genres_list:
            #f = plt.figure(figsize=(20, 10))
            sns.set()
            sns_plot = sns.displot(self.d.loc[self.d['genre'] == genre], x="hauteur_m", hue="espece",
                                   multiple="stack")

            sns_plot.savefig('Images/Genre_Distro_Espece_' + genre + '.png')
#        ax = sns.displot(self.data.loc[self.data['genre'] == genre], x="hauteur_m", hue="espece", multiple="stack")
           # f.savefig('Images/Genre_Distro_Espece_' + genre + '.png')
            plt.clf()
            plt.close('all')

    def graph_densite(self):
        for genre in self.genres_list:
            f = plt.figure(figsize=(20, 10))
            try:
                ax = sns.distplot(self.d['circonference_cm'].loc[self.d['genre'] == genre], rug=True, rug_kws={"color": "g"},

                          kde_kws={"color": "k", "lw": 3, "label": "KDE"},

                          hist_kws={"histtype": "step", "linewidth": 3,

                                    "alpha": 1, "color": "g"})
            except:
                pass

            f.savefig('Images/Genre_Densite_Circonf_' + genre + '.png')
            plt.clf()
            plt.close('all')


    def graph_pea_vol(self):
        print('Graphiques Vol')
        for nom, objet in self.data._portefeuille._actions_pea.items():
            m1 = memory_profiler.memory_usage()
            t1 = time.perf_counter()
            print('PEA', nom)

            methode = 'Adj Close'
            data = objet._donnees._panel[~objet._donnees._panel.index.duplicated()]

            # Volatility plot
            df_filled = data[[methode]].asfreq('D', method='ffill')
            df_returns = df_filled.pct_change()
            df_std = df_returns[-500:].rolling(window=30, min_periods=30).std()
            df_std.plot(label='Volatilité à la Clôture');
            plt.savefig('OutputFiles/volatility_' + methode + '_' + nom + '.png')
            plt.clf()
            plt.close('all')
            # del df_filled, df_returns, df_std, data
            # data = ''
            # df_filled = ''
            # df_returns = ''
            # df_std =''

            # del df_filled, df_returns, df_std, data
            # gc.collect()
            t2 = time.perf_counter()
            m2 = memory_profiler.memory_usage()
            time_diff = t2 - t1
            mem_diff = m2[0] - m1[0]
            print(f"It took {time_diff} Secs and {mem_diff} Mb to execute this pea vol method")

    def graph_pea_quant(self):
        print('Graphiques Quant')
        for nom, objet in self.data._portefeuille._actions_pea.items():
            m1 = memory_profiler.memory_usage()
            t1 = time.perf_counter()

            print('PEA quant : ', nom)

            # The top plot consisting of daily closing prices
            methode = 'Adj Close'
            data = objet._donnees._panel

            # Quantile-quantile plot
            figure = plt.figure(figsize=(8, 4))
            ax = figure.add_subplot(111)
            stats.probplot(data[-500:][methode].pct_change(periods=1).dropna(), dist='norm', plot=ax)
            plt.savefig('OutputFiles/quantile_' + methode + '_' + nom + '.png')
            plt.clf()
            plt.close('all')
            # del figure, ax, data
            # figure = ''
            # ax = ''
            # data = ''
            # del figure, ax, data
            # gc.collect()
            t2 = time.perf_counter()
            m2 = memory_profiler.memory_usage()
            time_diff = t2 - t1
            mem_diff = m2[0] - m1[0]
            print(f"It took {time_diff} Secs and {mem_diff} Mb to execute this pea quant method")

    def graph_pea_cours(self):
        print('Graphiques Cours')
        valeurs_iter = iter(self.data._portefeuille.pea_iter())

        for i in range(0, len(self.data._portefeuille._liste_pea)):
            objet = next(valeurs_iter)
            # for nom, objet in self.data._portefeuille._actions_pea.items():
            print('PEA cours: ', objet._nom)

            m1 = memory_profiler.memory_usage()
            t1 = time.perf_counter()
            p = PlotFinance()
            p.calc(objet._donnees._panel, objet._nom, 'Adj Close')
            t2 = time.perf_counter()
            m2 = memory_profiler.memory_usage()
            time_diff = t2 - t1
            mem_diff = m2[0] - m1[0]
            print(f"It took {time_diff} Secs and {mem_diff} Mb to execute this entire method")
            gc.collect()
        return 0

    def graph_pme(self):
        for nom, objet in self.data._portefeuille._actions_pme.items():
            print('PME', nom)
            # if isinstance(objet, Fonds):
            #     methode = 'Adj Close'
            #     # Plot the stock price
            #     data = objet._donnees._panel
            #     plt.figure(figsize=(10,6))
            #     mpf.plot(data.iloc[:,0:5], type='line', title='Cours de l\'action ' + nom
            #              ,savefig='OutputFiles/stockprice_' + methode + '_' + nom + '.png')
            #     mpf.plot(data.iloc[-500:,0:5], type='line', mav=(12,20,50),volume=True, title='Cours de l\'action ' + nom
            #              ,savefig='OutputFiles/mva_' + methode + '_' + nom + '.png')
            #     del data
            # if isinstance(objet, Indice):
            #     methode = 'Adj Close'
            #     # Plot the stock price
            #     data = objet._donnees._panel
            #     plt.figure(figsize=(10,6))
            #     mpf.plot(data.iloc[:,0:5], type='line', title='Cours de l\'action ' + nom
            #              ,savefig='OutputFiles/stockprice_' + methode + '_' + nom + '.png')
            #     mpf.plot(data.iloc[-500:,0:5], type='line', mav=(12,20,50),volume=True, title='Cours de l\'action ' + nom
            #              ,savefig='OutputFiles/mva_' + methode + '_' + nom + '.png')
            #     del data
            # if isinstance(objet, Action)|isinstance(objet, Bitcoin) :
            # The top plot consisting of daily closing prices
            methode = 'Adj Close'
            # print(nom, objet)
            # data = objet._donnees._panel
            data = objet._donnees._panel[~objet._donnees._panel.index.duplicated()]
            # data = objet._donnees._panel[[methode,'Volume']]
            # data.index = pd.to_datetime(data.index)
            # top = plt.subplot2grid((4, 4), (0, 0), rowspan=3, colspan=4)
            # top.plot(data.index, data[methode], label='Prix à la Clôture')
            # plt.title("Cours de l'action {}".format(nom))
            # plt.legend(loc=2)
            # The bottom plot consisting of daily trading volume
            # bottom = plt.subplot2grid((4, 4), (3,0), rowspan=1, colspan=4)
            # bottom.bar(data.index, data['Volume'])
            # plt.title("Volume de l'action {}".format(nom))
            # plt.gcf().set_size_inches(10, 6)
            # plt.subplots_adjust(hspace=0.75)
            # plt.savefig('OutputFiles/stockprice_' + methode + '_' + nom + '.png')
            # Volatility plot
            df_filled = data[[methode]].asfreq('D', method='ffill')
            df_returns = df_filled.pct_change()
            df_std = df_returns[-500:].rolling(window=30, min_periods=30).std()
            df_std.plot(label='Volatilité à la Clôture');
            plt.savefig('OutputFiles/volatility_' + methode + '_' + nom + '.png')
            del df_filled, df_returns, df_std
            df_filled = ''
            df_returns = ''
            df_std = ''
            plt.clf()
            plt.close()
            # Quantile-quantile plot
            figure = plt.figure(figsize=(8, 4))
            ax = figure.add_subplot(111)
            stats.probplot(data[-500:][methode].pct_change(periods=1).dropna(), dist='norm', plot=ax)
            # plt.show();
            plt.savefig('OutputFiles/quantile_' + methode + '_' + nom + '.png')
            # figur.clear()
            del figure, ax
            figure = ''
            ax = ''
            plt.clf()
            plt.close()
            # mva plot data = data.iloc[:,0:5]
            # mpf.plot(data.iloc[:,0:5], type='line',volume=True, title='Cours de l\'action ' + nom
            #         ,savefig='OutputFiles/stockprice_' + methode + '_' + nom + '.png')
            # mpf.plot(data.iloc[-500:,0:5], type='line', mav=(12,20,50),volume=True, title='Cours de l\'action ' + nom
            #         ,savefig='OutputFiles/mva_' + methode + '_' + nom + '.png')
            # plt.clf()
            # plt.close()

            # valeurs_iter = iter(self.data._portefeuille.pea_iter())

            m1 = memory_profiler.memory_usage()
            t1 = time.perf_counter()
            p = PlotFinance()
            p.calc(objet._donnees._panel, objet._nom, methode)
            t2 = time.perf_counter()
            m2 = memory_profiler.memory_usage()
            time_diff = t2 - t1
            mem_diff = m2[0] - m1[0]
            print(f"It took {time_diff} Secs and {mem_diff} Mb to execute this pme entire method")

            del data
            data = ''
            del df_filled, df_returns, df_std, figure, ax, data
            # mpf.plot(data.iloc[-500:], type='line', mav=(5,10,25),volume=True, title='Truee')
            gc.collect()

    def graph_fonds(self):
        for nom, objet in self.data._portefeuille._titres_fonds.items():
            print('Fonds', nom)

            # The top plot consisting of daily closing prices
            methode = 'Adj Close'
            # print(nom, objet)
            data = objet._donnees._panel[~objet._donnees._panel.index.duplicated()]

            # Volatility plot
            df_filled = data[[methode]].asfreq('D', method='ffill')
            df_returns = df_filled.pct_change()
            df_std = df_returns[-500:].rolling(window=30, min_periods=30).std()
            df_std.plot(label='Volatilité à la Clôture');
            plt.savefig('OutputFiles/volatility_' + methode + '_' + nom + '.png')
            del df_filled, df_returns, df_std
            df_filled = ''
            df_returns = ''
            df_std = ''
            plt.clf()
            plt.close()
            # Quantile-quantile plot
            figure = plt.figure(figsize=(8, 4))
            ax = figure.add_subplot(111)
            stats.probplot(data[-500:][methode].pct_change(periods=1).dropna(), dist='norm', plot=ax)
            # plt.show();
            plt.savefig('OutputFiles/quantile_' + methode + '_' + nom + '.png')
            # figur.clear()
            del figure, ax
            figure = ''
            ax = ''
            plt.clf()
            plt.close()
            m1 = memory_profiler.memory_usage()
            t1 = time.perf_counter()
            p = PlotFinance()
            p.calc(objet._donnees._panel, objet._nom, 'Adj Close')
            t2 = time.perf_counter()
            m2 = memory_profiler.memory_usage()
            time_diff = t2 - t1
            mem_diff = m2[0] - m1[0]
            print(f"It took {time_diff} Secs and {mem_diff} Mb to execute this fonds cic entire method")

            del data
            data = ''
            del df_filled, df_returns, df_std, figure, ax, data
            gc.collect()

    def graph_indices(self):
        for nom, objet in self.data._portefeuille._titres_indices.items():
            print('Indices', nom)

            # The top plot consisting of daily closing prices
            methode = 'Adj Close'

            data = objet._donnees._panel[~objet._donnees._panel.index.duplicated()]

            # Volatility plot
            df_filled = data[[methode]].asfreq('D', method='ffill')
            df_returns = df_filled.pct_change()
            df_std = df_returns[-500:].rolling(window=30, min_periods=30).std()
            df_std.plot(label='Volatilité à la Clôture');
            plt.savefig('OutputFiles/volatility_' + methode + '_' + nom + '.png')
            del df_filled, df_returns, df_std
            df_filled = ''
            df_returns = ''
            df_std = ''
            plt.clf()
            plt.close()
            # Quantile-quantile plot
            figure = plt.figure(figsize=(8, 4))
            ax = figure.add_subplot(111)
            stats.probplot(data[-500:][methode].pct_change(periods=1).dropna(), dist='norm', plot=ax)
            # plt.show();
            plt.savefig('OutputFiles/quantile_' + methode + '_' + nom + '.png')
            # figur.clear()
            del figure, ax
            figure = ''
            ax = ''
            plt.clf()
            plt.close()
            plt.close()

            m1 = memory_profiler.memory_usage()
            t1 = time.perf_counter()
            p = PlotFinance()
            p.calc(objet._donnees._panel, objet._nom, 'Adj Close')
            t2 = time.perf_counter()
            m2 = memory_profiler.memory_usage()
            time_diff = t2 - t1
            mem_diff = m2[0] - m1[0]
            print(f"It took {time_diff} Secs and {mem_diff} Mb to execute this indices entire method")

            del data
            data = ''
            del df_filled, df_returns, df_std, figure, ax, data
            gc.collect()

    def graph_bitcoins(self):
        for nom, objet in self.data._portefeuille._titres_bitcoins.items():
            print('Bitcoins', nom)

            # The top plot consisting of daily closing prices
            methode = 'Adj Close'

            data = objet._donnees._panel[~objet._donnees._panel.index.duplicated()]

            # Volatility plot
            data = data[~data.index.duplicated()]
            # self.panel_filtre.update({nom:panel})
            df_filled = data[[methode]].asfreq('D', method='ffill')
            df_returns = df_filled.pct_change()
            df_std = df_returns[-500:].rolling(window=30, min_periods=30).std()
            df_std.plot(label='Volatilité à la Clôture');
            plt.savefig('OutputFiles/volatility_' + methode + '_' + nom + '.png')
            del df_filled, df_returns, df_std
            df_filled = ''
            df_returns = ''
            df_std = ''
            plt.clf()
            plt.close()
            # Quantile-quantile plot
            figure = plt.figure(figsize=(8, 4))
            ax = figure.add_subplot(111)
            stats.probplot(data[-500:][methode].pct_change(periods=1).dropna(), dist='norm', plot=ax)
            # plt.show();
            plt.savefig('OutputFiles/quantile_' + methode + '_' + nom + '.png')
            # figur.clear()
            del figure, ax
            figure = ''
            ax = ''
            plt.clf()
            plt.close()
            plt.close()

            m1 = memory_profiler.memory_usage()
            t1 = time.perf_counter()
            p = PlotFinance()
            p.calc(objet._donnees._panel, objet._nom, 'Adj Close')
            t2 = time.perf_counter()
            m2 = memory_profiler.memory_usage()
            time_diff = t2 - t1
            mem_diff = m2[0] - m1[0]
            print(f"It took {time_diff} Secs and {mem_diff} Mb to execute this bitcoin entire method")
            plt.clf()
            plt.close('all')

            del data
            data = ''
            del df_filled, df_returns, df_std, figure, ax, data
            gc.collect()

    def sim_pea(self, methode='Adj Close'):
        for nom, objet in self.data._portefeuille._actions_pea.items():
            print('Simulation Monte Carlo', nom)
            # methode = 'Adj Close'
            data = objet._donnees._panel[methode]
            # data = self.data[methode]

            log_returns = np.log(1 + data.pct_change())
            u = log_returns.mean()
            var = log_returns.var()
            drift = pd.Series(u - (0.5 * var))
            stdev = pd.Series(log_returns.std())

            t_intervals = 250
            iterations = 10

            daily_returns = np.exp(drift.values + stdev.values * norm.ppf(np.random.rand(t_intervals, iterations)))

            price_list = np.zeros_like(daily_returns)
            price_list[0] = 100
            for t in range(1, t_intervals):
                price_list[t] = price_list[t - 1] * daily_returns[t]
            # Recherche du potentiel plus haut et plus bas du Monaco

            # Plot Monte-Carlo Simulation
            plt.figure(figsize=(10, 6))
            plt.xlabel('Jours')
            plt.ylabel('Prix prévisionnel')
            # plt.title('Méthode de Monte-Carlo')
            plt.title(
                'Méthode de Monte-Carlo (calculs d\'aléas sur les 250 jours de marché à venir) pour {}'.format(nom))
            plt.plot(price_list);
            plt.savefig('OutputFiles/monaco_' + methode + '_' + nom + '.png')
            plt.clf()
            plt.close()
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            price_list = ''
            log_returns = ''
            u = ''
            var = ''
            drift = ''
            stdev = ''
            daily_returns = ''
            data = ''
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            gc.collect()

    def sim_pme(self, methode='Adj Close'):
        for nom, objet in self.data._portefeuille._actions_pme.items():
            print('Simulation Monte Carlo', nom)
            # methode = 'Adj Close'
            data = objet._donnees._panel[methode]
            # data = self.data[methode]

            log_returns = np.log(1 + data.pct_change())
            u = log_returns.mean()
            var = log_returns.var()
            drift = pd.Series(u - (0.5 * var))
            stdev = pd.Series(log_returns.std())

            t_intervals = 250
            iterations = 10

            daily_returns = np.exp(drift.values + stdev.values * norm.ppf(np.random.rand(t_intervals, iterations)))
            ## À la place du prix S0, je prends 100
            # S0 = data.iloc[-1]
            price_list = np.zeros_like(daily_returns)
            price_list[0] = 100
            for t in range(1, t_intervals):
                price_list[t] = price_list[t - 1] * daily_returns[t]

            # Plot Monte-Carlo Simulation
            plt.figure(figsize=(10, 6))
            plt.xlabel('Jours')
            plt.ylabel('Prix prévisionnel')
            # plt.title('Méthode de Monte-Carlo')
            plt.title(
                'Méthode de Monte-Carlo (calculs d\'aléas sur les 250 jours de marché à venir) pour {}'.format(nom))
            plt.plot(price_list);
            plt.savefig('OutputFiles/monaco_' + methode + '_' + nom + '.png')
            plt.clf()
            plt.close()
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            price_list = ''
            log_returns = ''
            u = ''
            var = ''
            drift = ''
            stdev = ''
            daily_returns = ''
            data = ''
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            gc.collect()

    def sim_fonds(self, methode='Adj Close'):
        for nom, objet in self.data._portefeuille._titres_fonds.items():
            print('Simulation Monte Carlo', nom)
            # methode = 'Adj Close'
            data = objet._donnees._panel[methode]
            # data = self.data[methode]

            log_returns = np.log(1 + data.pct_change())
            u = log_returns.mean()
            var = log_returns.var()
            drift = pd.Series(u - (0.5 * var))
            stdev = pd.Series(log_returns.std())

            t_intervals = 250
            iterations = 10

            daily_returns = np.exp(drift.values + stdev.values * norm.ppf(np.random.rand(t_intervals, iterations)))
            ## À la place du prix S0, je prends 100
            # S0 = data.iloc[-1]
            price_list = np.zeros_like(daily_returns)
            price_list[0] = 100
            for t in range(1, t_intervals):
                price_list[t] = price_list[t - 1] * daily_returns[t]

            # Plot Monte-Carlo Simulation
            plt.figure(figsize=(10, 6))
            plt.xlabel('Jours')
            plt.ylabel('Prix prévisionnel')
            # plt.title('Méthode de Monte-Carlo')
            plt.title(
                'Méthode de Monte-Carlo (calculs d\'aléas sur les 250 jours de marché à venir) pour {}'.format(nom))
            plt.plot(price_list);
            plt.savefig('OutputFiles/monaco_' + methode + '_' + nom + '.png')
            plt.clf()
            plt.close()
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            price_list = ''
            log_returns = ''
            u = ''
            var = ''
            drift = ''
            stdev = ''
            daily_returns = ''
            data = ''
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            gc.collect()

    def sim_indices(self, methode='Adj Close'):
        for nom, objet in self.data._portefeuille._titres_indices.items():
            print('Simulation Monte Carlo', nom)
            # methode = 'Adj Close'
            data = objet._donnees._panel[methode]
            # data = self.data[methode]

            log_returns = np.log(1 + data.pct_change())
            u = log_returns.mean()
            var = log_returns.var()
            drift = pd.Series(u - (0.5 * var))
            stdev = pd.Series(log_returns.std())

            t_intervals = 250
            iterations = 10

            daily_returns = np.exp(drift.values + stdev.values * norm.ppf(np.random.rand(t_intervals, iterations)))

            price_list = np.zeros_like(daily_returns)
            price_list[0] = 100
            for t in range(1, t_intervals):
                price_list[t] = price_list[t - 1] * daily_returns[t]

            # Plot Monte-Carlo Simulation
            plt.figure(figsize=(10, 6))
            plt.xlabel('Jours')
            plt.ylabel('Prix prévisionnel')
            # plt.title('Méthode de Monte-Carlo')
            plt.title(
                'Méthode de Monte-Carlo (calculs d\'aléas sur les 250 jours de marché à venir) pour {}'.format(nom))
            plt.plot(price_list);
            plt.savefig('OutputFiles/monaco_' + methode + '_' + nom + '.png')
            plt.clf()
            plt.close()
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            price_list = ''
            log_returns = ''
            u = ''
            var = ''
            drift = ''
            stdev = ''
            daily_returns = ''
            data = ''
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            gc.collect()

    def sim_bitcoins(self, methode='Adj Close'):
        for nom, objet in self.data._portefeuille._titres_bitcoins.items():
            print('Simulation Monte Carlo', nom)
            # methode = 'Adj Close'
            data = objet._donnees._panel[methode]

            log_returns = np.log(1 + data.pct_change())
            u = log_returns.mean()
            var = log_returns.var()
            drift = pd.Series(u - (0.5 * var))
            stdev = pd.Series(log_returns.std())

            t_intervals = 250
            iterations = 10

            daily_returns = np.exp(drift.values + stdev.values * norm.ppf(np.random.rand(t_intervals, iterations)))

            price_list = np.zeros_like(daily_returns)
            price_list[0] = 100
            for t in range(1, t_intervals):
                price_list[t] = price_list[t - 1] * daily_returns[t]

            # Plot Monte-Carlo Simulation
            plt.figure(figsize=(10, 6))
            plt.xlabel('Jours')
            plt.ylabel('Prix prévisionnel')
            # plt.title('Méthode de Monte-Carlo')
            plt.title(
                'Méthode de Monte-Carlo (calculs d\'aléas sur les 250 jours de marché à venir) pour {}'.format(nom))
            plt.plot(price_list);
            plt.savefig('OutputFiles/monaco_' + methode + '_' + nom + '.png')
            plt.clf()
            plt.close()
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            price_list = ''
            log_returns = ''
            u = ''
            var = ''
            drift = ''
            stdev = ''
            daily_returns = ''
            data = ''
            del price_list, log_returns, u, var, drift, stdev, daily_returns, data
            gc.collect()
